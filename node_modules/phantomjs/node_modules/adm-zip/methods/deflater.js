/*
 * $Id: rawdeflate.js,v 0.5 2013/04/09 14:25:38 dankogai Exp dankogai $
 *
 * GNU General Public License, version 2 (GPL-2.0)
 *   http://opensource.org/licenses/GPL-2.0
 * Original:
 *  http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
 */
function JSDeflater(/*inbuff*/inbuf) {

    /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0.1
     * LastModified: Dec 25 1999
     */

    var WSIZE = 32768,		// Sliding Window size
        zip_STORED_BLOCK = 0,
        zip_STATIC_TREES = 1,
        zip_DYN_TREES = 2,
        zip_DEFAULT_LEVEL = 6,
        zip_FULL_SEARCH = true,
        zip_INBUFSIZ = 32768,	// Input buffer size
        zip_INBUF_EXTRA = 64,	// Extra buffer
        zip_OUTBUFSIZ = 1024 * 8,
        zip_window_size = 2 * WSIZE,
        MIN_MATCH = 3,
        MAX_MATCH = 258,
        zip_BITS = 16,
        LIT_BUFSIZE = 0x2000,
        zip_HASH_BITS = 13,
        zip_DIST_BUFSIZE = LIT_BUFSIZE,
        zip_HASH_SIZE = 1 << zip_HASH_BITS,
        zip_HASH_MASK = zip_HASH_SIZE - 1,
        zip_WMASK = WSIZE - 1,
        zip_NIL = 0, // Tail of hash chains
        zip_TOO_FAR = 4096,
        zip_MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
        zip_MAX_DIST = WSIZE - zip_MIN_LOOKAHEAD,
        zip_SMALLEST = 1,
        zip_MAX_BITS = 15,
        zip_MAX_BL_BITS = 7,
        zip_LENGTH_CODES = 29,
        zip_LITERALS = 256,
        zip_END_BLOCK = 256,
        zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES,
        zip_D_CODES = 30,
        zip_BL_CODES = 19,
        zip_REP_3_6 = 16,
        zip_REPZ_3_10 = 17,
        zip_REPZ_11_138 = 18,
        zip_HEAP_SIZE = 2 * zip_L_CODES + 1,
        zip_H_SHIFT = parseInt((zip_HASH_BITS + MIN_MATCH - 1) / MIN_MATCH);

    var zip_free_queue, zip_qhead, zip_qtail, zip_initflag, zip_outbuf = null, zip_outcnt, zip_outoff, zip_complete,
        zip_window, zip_d_buf, zip_l_buf, zip_prev, zip_bi_buf, zip_bi_valid, zip_block_start, zip_ins_h, zip_hash_head,
        zip_prev_match, zip_match_available, zip_match_length, zip_prev_length, zip_strstart, zip_match_start, zip_eofile,
        zip_lookahead, zip_max_chain_length, zip_max_lazy_match, zip_compr_level, zip_good_match, zip_nice_match,
        zip_dyn_ltree, zip_dyn_dtree, zip_static_ltree, zip_static_dtree, zip_bl_tree, zip_l_desc, zip_d_desc, zip_bl_desc,
        zip_bl_count, zip_heap, zip_heap_len, zip_heap_max, zip_depth, zip_length_code, zip_dist_code, zip_base_length,
        zip_base_dist, zip_flag_buf, zip_last_lit, zip_last_dist, zip_last_flags, zip_flags, zip_flag_bit, zip_opt_len,
        zip_static_len, zip_deflate_data, zip_deflate_pos;

    var zip_DeflateCT = function () {
        this.fc = 0; // frequency count or bit string
        this.dl = 0; // father node in Huffman tree or length of bit string
    };

    var zip_DeflateTreeDesc = function () {
        this.dyn_tree = null;	// the dynamic tree
        this.static_tree = null;	// corresponding static tree or NULL
        this.extra_bits = null;	// extra bits for each code or NULL
        this.extra_base = 0;	// base index for extra_bits
        this.elems = 0;		// max number of elements in the tree
        this.max_length = 0;	// max bit length for the codes
        this.max_code = 0;		// largest code with non zero frequency
    };

    /* Values for max_lazy_match, good_match and max_chain_length, depending on
     * the desired pack level (0..9). The values given below have been tuned to
     * exclude worst case performance for pathological files. Better values may be
     * found for specific files.
     */
    var zip_DeflateConfiguration = function (a, b, c, d) {
        this.good_length = a; // reduce lazy search above this match length
        this.max_lazy = b;    // do not perform lazy search above this match length
        this.nice_length = c; // quit search above this match length
        this.max_chain = d;
    };

    var zip_DeflateBuffer = function () {
        this.next = null;
        this.len = 0;
        this.ptr = new Array(zip_OUTBUFSIZ);
        this.off = 0;
    };

    /* constant tables */
    var zip_extra_lbits = new Array(
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0);
    var zip_extra_dbits = new Array(
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13);
    var zip_extra_blbits = new Array(
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7);
    var zip_bl_order = new Array(
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15);
    var zip_configuration_table = new Array(
        new zip_DeflateConfiguration(0, 0, 0, 0),
        new zip_DeflateConfiguration(4, 4, 8, 4),
        new zip_DeflateConfiguration(4, 5, 16, 8),
        new zip_DeflateConfiguration(4, 6, 32, 32),
        new zip_DeflateConfiguration(4, 4, 16, 16),
        new zip_DeflateConfiguration(8, 16, 32, 32),
        new zip_DeflateConfiguration(8, 16, 128, 128),
        new zip_DeflateConfiguration(8, 32, 128, 256),
        new zip_DeflateConfiguration(32, 128, 258, 1024),
        new zip_DeflateConfiguration(32, 258, 258, 4096));


    /* routines (deflate) */

    var zip_deflate_start = function (level) {
        var i;

        if (!level)
            level = zip_DEFAULT_LEVEL;
        else if (level < 1)
            level = 1;
        else if (level > 9)
            level = 9;

        zip_compr_level = level;
        zip_initflag = false;
        zip_eofile = false;
        if (zip_outbuf != null)
            return;

        zip_free_queue = zip_qhead = zip_qtail = null;
        zip_outbuf = new Array(zip_OUTBUFSIZ);
        zip_window = new Array(zip_window_size);
        zip_d_buf = new Array(zip_DIST_BUFSIZE);
        zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);
        zip_prev = new Array(1 << zip_BITS);
        zip_dyn_ltree = new Array(zip_HEAP_SIZE);
        for (i = 0; i < zip_HEAP_SIZE; i++) zip_dyn_ltree[i] = new zip_DeflateCT();
        zip_dyn_dtree = new Array(2 * zip_D_CODES + 1);
        for (i = 0; i < 2 * zip_D_CODES + 1; i++) zip_dyn_dtree[i] = new zip_DeflateCT();
        zip_static_ltree = new Array(zip_L_CODES + 2);
        for (i = 0; i < zip_L_CODES + 2; i++) zip_static_ltree[i] = new zip_DeflateCT();
        zip_static_dtree = new Array(zip_D_CODES);
        for (i = 0; i < zip_D_CODES; i++) zip_static_dtree[i] = new zip_DeflateCT();
        zip_bl_tree = new Array(2 * zip_BL_CODES + 1);
        for (i = 0; i < 2 * zip_BL_CODES + 1; i++) zip_bl_tree[i] = new zip_DeflateCT();
        zip_l_desc = new zip_DeflateTreeDesc();
        zip_d_desc = new zip_DeflateTreeDesc();
        zip_bl_desc = new zip_DeflateTreeDesc();
        zip_bl_count = new Array(zip_MAX_BITS + 1);
        zip_heap = new Array(2 * zip_L_CODES + 1);
        zip_depth = new Array(2 * zip_L_CODES + 1);
        zip_length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zip_dist_code = new Array(512);
        zip_base_length = new Array(zip_LENGTH_CODES);
        zip_base_dist = new Array(zip_D_CODES);
        zip_flag_buf = new Array(parseInt(LIT_BUFSIZE / 8));
    };

    var zip_deflate_end = function () {
        zip_free_queue = zip_qhead = zip_qtail = null;
        zip_outbuf = null;
        zip_window = null;
        zip_d_buf = null;
        zip_l_buf = null;
        zip_prev = null;
        zip_dyn_ltree = null;
        zip_dyn_dtree = null;
        zip_static_ltree = null;
        zip_static_dtree = null;
        zip_bl_tree = null;
        zip_l_desc = null;
        zip_d_desc = null;
        zip_bl_desc = null;
        zip_bl_count = null;
        zip_heap = null;
        zip_depth = null;
        zip_length_code = null;
        zip_dist_code = null;
        zip_base_length = null;
        zip_base_dist = null;
        zip_flag_buf = null;
    };

    var zip_reuse_queue = function (p) {
        p.next = zip_free_queue;
        zip_free_queue = p;
    };

    var zip_new_queu